用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，不能用来进行原子性操作。
由于volatile仅仅保证对单个volatile变量的读/写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。
在功能上，监视器锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。


理解volatile特性的一个好方法是：把对volatile变量的单个读/写，看成是使用同一个监视器锁对这些单个读/写操作做了同步。
监视器锁的happens-before规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个volatile变量的读，
总是能看到（任意线程）对这个volatile变量最后的写入

volatile提供内存可见性，强制线程使用主内存而不是自己的内存。通过插入内存屏障防止jvm对指令进行重拍(例如：双重检查锁、上下文和true的关系)


volatile会禁用处理器的快速的访问内存或寄存器，直接从主内存中取。所以对于成员变量，如果有多线程访问，
加上violatile就可以让他们都从一个地方读取，不过这个不能保证原子执行，只能保证能看到最新的。
不过由于大家都没有本地缓存势必性能有所影响，而且volatile也禁止jvm优化指令重排
只能保证可见性，不能保证原子性，那么多读少写的情况，能不能对写操作进行同步而不管读？可以的。

volatile能代替countdownlatch，轻量级

volatile写之前读之后，写读，不能重排序

volatile只能修饰类变量和实例变量，不能修饰方法参数、局部变量、实例常量类常量。

#####并发编程三个特性
原子性、可见性、有序性(有依赖关系的保证结果正确)

原子性：所有操作都执行并且不受任何因素干扰而中断或都不执行。如转账。赋值语句Object o = new Object()
多个原子性的操作结合在一起未必是原子的。
volatile不保证原子性，synchronized保证。

可见性：当一个线程对共享变量修改，另外线程可以立即看到修改后的最新值。

有序性：程序代码在执行过程中的先后顺序。
指令重排(保证依赖关系的前提)。单线程中，java编译器、处理器为保证速度，保证程序最终运算结果是编码时所期望的。多线程则需要自己保证
load(){
  if(!initialized){
    context = loadContext(); //1
    initialized = true; //2
  }
  return context;
}
若是1和2在优化时进行颠倒，那么多线程下就有问题。。
对initialized加上volatile，仅仅保证可见性和有序性(不重排序volatile之前后之后的)，但是不能保证并发原子性(多个线程同时查看initialized)

#####JVM保证三大特性
JVM采用内存模型的机制来屏蔽各个平台和操作系统之间内存访问的差异，以实现java程序在各个平台下达到一致的内存访问效果。如java在任何平台
下int类型就是4个字节，一直内存访问效果。
java内存模型规定所有变量都存在于主内存(RAM)中，每个线程有自己的工作内存或本地内存，线程对变量的所有操作都必须在自己的工作内存中，不能
直接对主内存操作，并且每一个线程都不能访问其他线程的工作内存或本地内存。

jmm与原子性
java中对基本数据类型变量、引用类型的读取赋值都是原子性的，
x=10原子。若其他线程写入x=11，则要么是10要么是11，不能是其他情况
y=x。不是原子，先获取x(从本内存或主存，存入本内存)，对y赋值(本内存)，写回主内存
y++。不是原子，获取y(从本内存或主存，存入本内存)，对y+1(本内存)，写回主内存
z=z+1，不是原子，获取z(从本内存或主存，存入本内存)，z+1(本内存)，写回主内存
多个原子性的操作在一起就不再是原子性操作。
简单的读取与赋值是原子性，将一个变量赋值给另一个操作非原子
jmm模型只保证基本读取和赋值的原子性，要想某些代码段具备原子，使用synchronized或者JUC的lock，或atomicxx
volatile不具有原子性

jmm与可见性
线程操作某共享变量，需要先从主存加载到工作内存，操作值，写入工作内存，再刷新到主存(时间不确定)。
java提供了三种方式保证可见性
1. volatile，对共享资源读会直接从主内存中读取，缓存到本地内存，修改后，立即刷新到主存，并让其他线程失效，其他线程操作时，
需要先从主存中再次获取。
2. 通过synchronized，同一时刻只有一个线程获取锁，然后执行，锁释放之前，对变量的修改刷新到主存。
3. 通过JUC提供的显示lock，
volatile保证可见性。

jmm与有序性
jmm中，允许编译器和处理器对指令重排序，多线程下可能会影响到程序的正确性。
java提供三种保证有序性
1. volatile
2. synchronized，同步
3. lock，同步
jmm具备一些天生的有序性规则，不需要任何同步手段，称为Happens-before。若两个操作执行次序无法从happens-before原则推导，则无法
保证有序，也就是说虚拟机或处理器可以随意对它们进行重排序处理。
1. 程序次序规则：一个线程内，程序按照编写的顺序执行得到期望的最终结果
2. 锁定规则：unlock操作先行发生于同一个锁的lock操作，不论多线程还是单线程
3. volatile规则：对一个变量的写操作要早于对这个变量之后的读操作。
4. 传递规则：操作a先于b，b先于c，则得出a先于c。
5. 线程启动规则：thread对象的start方法先于对线程的任何动作，只有start之后才能真正运行，否则thread只是一个对象
6. 线程中断规则：对线程执行interrupt方法肯定先于捕获到中断信号。
7. 线程的终结规则：线程中所有操作都先于线程的终止检测
8. 对象的终结规则：一个对象初始化完成先于finalize
volatile具有保证顺序性的语义

#####volatile深入理解
1. 保证不同线程之间对共享变量操作时的可见性，一个线程修改，另一个线程立即看到。
写线程发生后刷新到主存和让其他线程副本失效，其他线程操作本地内存时发现失效(硬件上就是CPU的L1或L2的Cache Line失效)，从新读取主存。
2. 禁止对指令重排序
禁止JVM和处理器对volatile修饰的指令重排序，但是对volatile前后无依赖关系的指令则可以随便
int x = 0
int y = 1
volatile int z = 20 
x++
y--
对z操作之前的x和y不管，对z之后的x和y不管。
3. volatile不保证原子性
由于cpu时间片调度会在多线程间切换，而只要没有被修改刷新到主存的变量，那么其他线程内副本就是可用状态。

4. volatile原理
对OpenJDK下unsafe.cpp源码查看，被volatile修饰的变量存在于一个"lock;"的前缀,相当于是一个内存屏障：
a. 确保指令重排序时不会将其后面的代码排到内存屏障之前
b. 确保指令重排序不会将其前面的代码排到内存屏障之后
c. 确保在执行到内存屏障修饰的指令时前面的代码全部执行完
d. 强制将线程工作内存中值的修改刷新至主存
e. 如果是写操操作，则导致其他线程工作内存(CPU Cache)中的缓存数据失效

5. 应用场景
a. 开关控制
b. 状态标记：
if(!initialized){
    context = loadContext(); 
    initialized = true; //volatile
  }
  防止指令重排序
  
c. double-check

6. volatile和synchronized
a. 使用上
volatile修饰实例变量或类变量，可以为null，synchronized修饰方法或语句块，monitor不能为null
b. volatile不保证原子性，synchronized排他，只能同步执行，保证原子
c. 都可实现可见性，synchronized借助JVM的monitor enter和monitor exit同步代码串行化，monitor exit时所有共享资源刷新
到主存。volatile使用机器指令(硬编码)"lock;"禁止重排序，迫使其他线程工作内存中的数据失效，不得不到主存再次加载。
d. volatile禁止JVM编译器以及处理器对其修饰的变量进行重排序，synchronized使程序串行化执行，即使其内部有重排序，但是没有多
线程，也不会有问题
e. volatile不会使线程陷入阻塞，synchronized对于获取不到锁的线程进入阻塞


